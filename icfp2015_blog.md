Most people living in Auckland would likely agree that it would be a bad thing if the city was destroyed by gigantic ancient sea creature whose mind is both terrifying and incomprehensible to us mere mortals. Or if all of a sudden portals appeared around the city that spawned various hellbeasts. In order to protect mankind from the unwitting use of dangerous knowledge causing such events; this years ICFP contest was set up to find algorithmic ways of preventing these imminent disasters... That is in essence the backstory to ICFP[ref to contest] contest.

### The ~~problems~~opportunity:
The challenge consisted of finding command sequences for a Tetris like game that would simultaneously score a lot of points by clearing lines and contain specific sequences of "power words". The game had three main concepts:
 - The board [include  image of board], consisting of a hexagonal grid where some spaces are locked/occupied
 - The units consisting of various shapes of hexagon combinations with a pivot point around which the shapes can be rotated
 - The source which determines the order in which the units appear on the board

The command sequence we generated would indicate how the units would be moved on the board and locked into position. An example command would be "palb" which would move a unit west, south west, south east, east. To add to the challenge, if the command sequence contained specific secret power words bonus points were awarded. Finding what sequences were considered power words was also part of the contest for instance "ia! ia!" was included on in one of the problem boards in its initial layout.

Since nothing beyond the problem specification and problems was provided we initially set out to create a simulator. Creating the simulator let us visually verify  command sequences and discard commands that broke the rules of the game. It became the central piece we used to find good commands.

### Searching for magic
Once we had a working and pretty reliable simulator we needed to find command sequences that gave us the highest scores. We divided this into four parts:
 - Find possible end positions to move to
 - Rank the end positions so we can pick the best one
 - Find a path from the spawn position for a unit to the end position
 - Replace this path with one that is isomorphic and uses as many "power words" as possible

Finding possible positions involved putting a unit in all positions (and rotations!) on the board and checking if it was still inside the board, then filtering so only positions from which the unit could be locked on the board was returned. To get a sense of the number of checks needed, a tiny 2x2 board and a simple two-piece unit has 19 position checks but only 3 valid ones (ignoring symmetric positions). These number grow fast when the state space expands.

To rank the end positions found we evaluated their fitness based on the resulting board configuration. Finding good evaluators is essential, and thankfully [ref https://codemyroad.wordpress.com/2013/04/14/tetris-ai-the-near-perfect-player/] had found a few good ones for regular Tetris, so we reused those and just added a couple to complement them. We ended up with evaluator for a board's depth, bumpiness, hole count, line fullness, snugness and lines that would be completed. Having holes in the board sometimes makes it impossible to clear lines. Bumpiness can make it harder to find good spots for subsequent pieces. Ensuring lines get more and more full is good since it brings us closer to the goal of clearing lines.

Pathfinding is a fun problem since it can be solved in lots of ways, depth- or breadth-first search, iterative depth-first search, Dijkstra's algorithm, etc. We chose A* since it guarantees to find the best path from A to B and lets you define the criteria for what a good path is by varying the cost for different moves and having a custom heuristic to estimate the cost of reaching the goal.

### How important is a hole?
The above gave decent results, but the results varied between the supplied problems. Some boards started out with lots of holes below some initial locked blocks, and because of that our algorithm tended to try to fill out that space before attempting to clear out the initial blocks. We realized that we needed specialised evaluators for each of the different problems. Turns out nature has supplied us with a great example of a way to create specialisation: evolution!

### Darwin to the rescue!
We had initially tried evolving whole command sequences, but found that it had to run for quite a while to find good ones. However, we wanted to optimise the weights we gave each evaluator for each board and there are far fewer variables involved in that problem. We used JGAP [ref to JGAP] and specified the score for a command sequence generated by a run of the simulator with the supplied weights as the fitness function. The good thing with this was that evaluating each individual weight combination in the evolutionary algorithm is highly parallelizable. The downside is that for some boards finding a good position for a unit could take up to 10 seconds! That meant that a single run of those problems could take over 4 hours. On other problems we quickly found some decent evaluator weights that enabled us to score in the top 40. In the end, we hand picked weights for the difficult problems and generated command sequences with those.

### Power words
Sadly we didn't know our H.P. Lovecraft well enough to figure out that many of the power words. For those we did find, we generated isomorphic command sequences (sequences of commands that put the block in the same position but by an alternate route) and tried to insert them in the command sequences we generated. Instead of going as quickly as possible from the spawn position to its goal, this caused the blocks to dance and wiggle before settling in the desired place.

### What it looked like and lessons learned
As a final note we did spend a lot of time watching the simulator run. So here's a sample run of one of the problems (note the wiggling):
[[[[[Include a film of our simulator running a short problem]]]]]

All in all, ICFP contests are a lot of fun, but have an unadvertised sleep-depriving effect! It is extremely exciting how fast a team can move with a clean slate (and not having to worry about maintenance). Techwise - if you are thinking about using evolutionary algorithms, do make sure that the fitness function is as fast as possible.

Cheerio and watch out for the deep ones!

